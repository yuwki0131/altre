# QA.md - プロジェクト進行における不明点・質問事項

## 1. プロジェクト構成・技術選定について

### Q1: プロジェクト構成
- 現在README.mdのみが存在していますが、Rustプロジェクトの基本構成（Cargo.toml、src/ディレクトリなど）はまだ作成していない状態でしょうか？
  - ありません。これから作成していきます。
- プロジェクトのディレクトリ構成について具体的な方針はありますか？
  - プロジェクトはモノレポとします。すべての成果物、設計ドキュメント、タスク管理用ファイルをすべてこのリポジトリで管理します。
  - 以下がディレクトリ構成です。
    - docs ... 設計、アーキテクチャ、実装ガイドラインを格納します
    - app ... アプリケーションの成果物、実装を格納します
    - test ... テスト、特にE2Eテストやテスト用のデータやファイル等を格納します
    - tasks ... 実装タスクを整理したものを格納します。作業はこのディレクトリにあるファイル単位で実行します。
      - todo ... TODOタスク(未実現かつ未着手のタスク)を格納します
      - proceeding ... 進行中タスクを格納します
      - done ... 完了済みタスクを格納します
    - manuals ... 作成したアプリケーションのマニュアルを格納します
    - temp ... 一時的な設計作業や、調査タスク等の情報やメモを格納するために使います。

### Q2: 依存関係・クレート選定
- HarfBuzzのRustバインディングはどのクレートを使用予定ですか？（harfbuzz-rs、rustybuzz等）
  - rustybuzzにしましょう。
- ウィンドウ管理・イベント処理のクレートは何を使用予定ですか？（winit、egui、tauri等）
  - tauriで。
- Waylandサポートについて、特定のクレートを想定していますか？
  - 未定です。これからの設計タスクで詰めていきます。

### Q3: 拡張言語alisp
- alispインタープリターの実装は自作予定ですか、それとも既存のScheme/Lispインタープリターを組み込み予定ですか？
  - 自作します。これはいちから設計します。
- Emacsとの互換性レベルはどの程度を想定していますか？（構文のみ、標準ライブラリ、内部API等）
  - Emacsとの互換性はほぼありません。ただコンセプトの一部を引き継ぎます。引き継ぐコンセプトは、以下です。(詳細は今後詰めていきます)
    - Emacsライクなキーバインディング(C-c)
    - バッファ、マーク＆ヤンク等の基本的なEmacsの操作と概念
    - M-xで起動できるミニバッファ
    - Lisp likeな言語での機能拡張が可能

## 2. MVP実装の優先順位・スコープについて

### Q4: テキストモデルの選択
- README.mdではピーステーブルを推奨していますが、まずはシンプルなギャップバッファから始めるべきでしょうか？
  - そうですね、ギャップバッファ
- 巨大ファイル対応（部分読み込み・低メモリ）はMVPに含めますか？
  - 巨大ファイル対応はMVPでは対象外としてください。

### Q5: UI/レンダリング
- MVPでのターゲットはTUIのみでしょうか？それともGUIも含めますか？
  - まずはTUIにしましょう。
- ミニバッファの実装において、補完機能はMVPに含めますか？
  - MVPでは補完機能は不要です

### Q6: キーバインド・コマンド
- MVPでのキーバインドは最小限（exit、基本移動等）に留めますか？
  - MVPでは最小限のキーバインドにしてください
- M-x以外の基本的なEmacsキーバインド（C-x C-f等）はMVPに含めますか？
  - C-x C-f(file open)とC-x C-s(file save)、基本的なカーソル移動のみをMVPとしましょう。多すぎる機能はMVPには不的確です。

## 3. 開発環境・ツールチェーンについて

### Q7: 開発環境
- NixOS環境での開発を前提としていますが、開発者がNixOS以外の環境でも開発可能にしますか？
  - MVPではNixOS環境のみで開発できればいいです。
- CI/CD、テスト環境についてどの程度整備しますか？
  - CI/CDはMVPから外します。テスト環境については最低限のテストコード実装のみ(Rust内に閉じる)をMVPのスコープとします

### Q8: ビルド・パッケージング
- Nixパッケージの作成は開発初期から行いますか？
  - Nixパッケージの作成は最初は不要です
- 他のディストリビューション向けのパッケージングは後回しで良いでしょうか？
  - 他のディストリブーション向けのパッケージングも後回しでOKです

## 4. 実装順序・マイルストーンについて

### Q9: 実装の進め方
- コア機能から実装していく際の具体的な順序は決まっていますか？
  - 具体的な順序は未定です
- 各機能の完成度の基準（どこまで実装したら次のステップに進むか）は？
  - まずは機能群の洗い出しから行いたいです。

### Q10: テスト戦略
- MVP段階でのテスト方針は？（単体テスト、統合テスト、手動テスト等）
  - テストは基本的にテストコードによるテスト
- プロパティベーステストやファズテストは開発初期から導入しますか？
  - プロパティベースのテストは開発初期から導入しましょう。ファズテストは一旦MVPでは対象外とします。

## 5. パフォーマンス・制約について

### Q11: パフォーマンス目標
- MVPでのパフォーマンス目標は設定していますか？（起動時間、描画FPS、メモリ使用量等）
  - これは未定です。今後のタスクで整理していきます。
- ベンチマーク・プロファイリング環境の整備は開発のどの段階で行いますか？
  - MVPの次のステップで実施するかどうか、実施概要を検討します。

## 6. コミュニティ・ライセンスについて

### Q12: オープンソース化
- このプロジェクトはオープンソースとして公開予定ですか？
  - 現在は個人用リポジトリとして開発しており、公開可否は未定です。
- ライセンスの選定は済んでいますか？（GPL互換性を考慮した選択）
  - ライセンスは未定です。利用・再配布は各自の責任でお願いします。

## 7. 追加の不明点・確認事項

### Q13: TUIとTauriの整合性について
- TUIをターゲットとしていますがTauriを選択している理由は？
  - 回答がぶれていますね、最終的にGUIにしたいのでtauriと回答しましたが、MVPでは、TUIです。なのでTUIを作る→動作保証やコンセプトが固まれば最終的にGUIで実装を行いこれは、tauriでという意味です。
- TauriはWebベースのGUIフレームワークですが、TUIの実装には別のクレート（ratatui、crossterm等）が必要では？
  - TUI実装時はratatuiでお願いします

### Q14: MVPで実装すべき具体的な機能
- ファイルオープン（C-x C-f）の具体的な実装：ミニバッファでのファイルパス入力？ファイルブラウザ？
  - ミニバッファでのファイルパス入力です。ここはEmacsと基本的な振る舞いは合わせます。
- 基本的なカーソル移動の範囲：矢印キー、hjkl、C-n/C-p/C-f/C-b等、どこまで含める？
  - 矢印キー及び、C-n/C-p/C-f/C-bでお願いします。hjklは不要です。
- テキスト編集：文字入力、削除（Backspace/Delete）、改行等の基本操作はMVPに含める？
  - 含めます。文字入力、削除（Backspace/Delete）、改行のみで良いです。

### Q15: alisp統合のタイミング
- MVPでalispインタープリターの実装はどこまで行う？
  - alispはMVPでは不要です。MVPでは最低限テキストエディタとして起動し、file open, 基本的な編集作業, file save, 終了のみの機能を目指します。
- 最初はRustで全て実装し、後からalisp機能を追加する方針？
  - 基本的にRustですべて実装してください。alispでの機能拡張は、あとからalisp用のインターフェイスと言語処理系を用意追加実装する方針です。
- それとも初期からalisp統合を前提とした設計にする？
  - 最初はalisp統合は不要です。

### Q16: プロジェクト管理・作業フロー
- tasksディレクトリでのタスク管理とGitHubのIssue/PRとの使い分けは？
  - GitHubでのIssue/PRは作成しません。プロジェクト管理はすべてこのディレクトリ配下にあるmarkdownファイルで行います。
  - 1タスク1マークダウンファイルで、前述のtasksディレクトリで管理、どのディレクトリに入っているかで、進行状況を表します。進捗状況や途中敬意、タスク中断状況等のメモがあれば、それは各タスク用のmdファイルに追記する形で記録、管理します。
  - ブランチ管理/コミット管理はこちら側で実施するので、考慮不要です。
- 複数人での開発を想定している？それとも現段階は1人での開発？
  - 個人で開発します。

### Q17: TUIライブラリの選択
- TUIの実装には具体的にどのクレートを使用する？（ratatui、tui-rs、crossterm等）
  - ratatuiで良いです。
- ターミナルの互換性（色対応、マウス対応等）はどの程度考慮する？
  - 色対応は行ってください。マウス対応は不要です。

## 8. 最終確認事項

### Q18: MVP機能の詳細仕様
- ミニバッファでのファイルパス入力時の UI/UX：
  - パス補完機能は必要？（Tab補完等）
    - これは動作確認の生産性を上げるため、本来であればMVPの範疇から外れるはずですが、追加をお願いします。
  - 相対パス・絶対パス両対応？
    - これは動作確認の生産性を上げるため、本来であればMVPの範疇から外れるはずですが、追加をお願いします。
  - 存在しないファイルのオープン（新規作成）は可能？
    - これは動作確認の生産性を上げるため、本来であればMVPの範疇から外れるはずですが、追加をお願いします。
- 終了方法：exit コマンドのみ？ C-x C-c等のキーバインドも？
  - これはC-x C-cのキーバインドも追加してください。

### Q19: ギャップバッファ実装の仕様
- エンコーディング：UTF-8のみ対応？他のエンコーディングは？
  - 他のエンコーディングは一旦MVPの対象外としてください。
- 改行コード：LF のみ？CRLF 対応は？
  - MVPではLFのみとし、CRLF対応は後ほど対応という方針です。
- メモリ効率：ギャップサイズの初期値・拡張戦略は？
  - これは設計段階で考慮します。

### Q20: エラーハンドリング・UI
- ファイル読み込み失敗時の表示方法：ステータスライン？ミニバッファ？
  - ミニバッファで。
- 保存失敗時（権限不足等）の処理方法は？
  - 保存失敗時はエラーをミニバッファに表示する形にしてください。
- 不正なキー入力時の動作は？
  - 無視(何もしない)

### Q21: 設定・カスタマイズ
- MVPでの設定項目：キーバインド変更は可能？色設定は？
  - キーバインド変更機能は、alisp実装時に実装します。なので、MVPでは変更不要でOKです。色設定も同様です。
- 設定ファイルの形式・場所は？（~/.config/altre/ 等）
  - 設定ファイルはMVPでは不要で大丈夫です。alispスクリプトが設定ファイルになります。なので、alisp未実装段階では考慮不要です。
  - ちなみに設定ファイルの形式は、xxx.alispというタイプの(alispが拡張子)のファイルで、設定ファイルのデフォルト格納場所は、~/.alispとなる予定です。

## 9. GUI移行に向けた検討事項

> **更新 (2025-03-15):** Slint ベース GUI 計画は撤回され、Tauri を候補とした再設計を進行中です。以下の Q&A は過去の議論記録として保持しています。新方針確定後に改訂版を追加します。

### Q22: UI 抽象化レイヤの構成
- ratatui ベースの TUI と Slint ベースの GUI をどう共存させるか？
  - 決定: 実装をバックエンドとフロントエンドに明確に分離する。まずは ratatui ベースでバックエンド（バッファ管理や言語処理系など）とフロントエンド（表示・キーハンドリング）を切り分け、TUI のリグレッションが無いことを確認した上で、フロントエンド部分に Slint 実装を追加する。ディレクトリ構成は任意だが「`ui/tui` と `ui/gui`」を分ける方針とする。
- レンダラー間で共有するテーマ・レイアウト定義の粒度は？
  - 決定: カラースキームやレイアウト計算はレンダラー依存とし、各フロントエンドが独自に管理する。GUI 側の自由度を優先する。

### Q23: イベントループ統合
- Slint のイベントループを採用した場合、既存 `App::run` と `InputHandler` の制御フローをどう組み合わせるか？
  - 決定: Rust 側（既存 `App::run`）で駆動し、状態更新後に Slint へレンダリングを通知する方式とする。
- Crossterm 依存の入力処理を今後も保持するか？
  - 決定: Crossterm 依存部は TUI フロントエンド専用として切り出し、GUI 実装からは分離する。

### Q24: ビルドチェーンと依存関係
- Slint コンパイラ (`slint-build`) をビルドフローに統合する方法は？
  - 決定: `slint::include_slint!` を用いてコンパイル時に `.slint` を直接組み込む。ビルドコマンドは可能な限りシンプルに保つ。
- CI や開発環境に必要な追加依存（Qt/Wayland ランタイム等）は？
  - 方針: 追加依存は最小限に留める。必要ライブラリを洗い出す検討タスクを別途設け、設計時に具体的なリストを確定させる。

### Q25: 入力方式と IME 検証
- Wayland (Hyprland) や Windows/macOS で日本語 IME をどのように検証するか？
  - 方針: 実装前に別タスクとして調査を行い、日本語 IME の自動テストやチェック方法を検討した上で最適な検証手法を決定する。
- Slint と altre のミニバッファ連携における文字幅計算・文字列変換エッジケースの扱いは？
  - 決定: 文字幅補正は Rust 側で担保し、外部ライブラリへの依存度を下げる。

### Q26: 配布とリリース戦略
- GUI 版の配布形態（AppImage、Flatpak、Windows MSI 等）はどうするか？
  - 決定: 当面は TUI と同様にソース配布（`cargo run`）とし、バイナリ配布は将来の検討課題とする。
- TUI/GUI の同梱方針は？
  - 決定: 同一バイナリで提供し、デフォルトは GUI 起動、`--tui` 等のコマンドラインオプションで TUI に切り替える。

### Q27: Slint クレートのバージョン固定と取得方法
- ネットワーク制限下で Slint をどのバージョンで取得・検証するか？
  - 未決: 現在の環境では crates.io へアクセスできないため、`slint` クレート（想定 1.5.x）のダウンロードと GUI 機能のビルド確認は後続環境で実施する必要がある。ローカルでオフライン取得する手段（事前のキャッシュ配布など）を検討する。

## 10. Tauri GUI導入に関する検討事項

### Q28: Tauri プロジェクト構成の配置
- `src-tauri` をどこに置き、既存の Rust クレート構成とどう共存させるか？
  - 方針: ルート配下に `gui/tauri/`（フロントエンド資産）と `src-tauri/`（Tauri ランタイム）を追加し、`altre` クレートをワークスペースメンバーとして再編する案を検討する。モノレポ方針を維持しつつ、TUI と GUI のビルド成果物を明確に分離する。
  - 回答: 既存実装(Rustのsrc実装)と名前がかぶってしまいますね。できれば、起動起点はsrc側のmainで起動し(つまりsrc-tauriはsrc)になり、Web実装はfrontend/srcとでもするか(別の名前でもいいです)名前は何でもいいですが、別ディレクトリとして切り出し、これをWeb実装(Tauriでいうところのsrc)とする。

### Q29: フロントエンド技術スタック
- Tauri の Web フロントエンドはどのフレームワーク（Svelte/React/Vanilla 等）を採用するか？
  - 未決: 依存軽減と日本語入力 (IME) の挙動、アクセシビリティを考慮した比較が必要。候補ごとのビルドサイズ・学習コスト・オフライン対応を調査した上で決定する。
  - 回答: 豊富なノウハウとライブラリの安定性を考慮してReactを採用します。Svelteプロジェクトは検討先候補としては魅力的だが実装ナレッジは他フレームワークと比較したときに比較的少ない。Vanillaは安定性に関しては十分であるが、メンテナス性においてフレームワーク採用時と比較して劣後する。また今回注力したいのは新技術最世によるアーキテクチャ刷新は目的ではないため、最も安定性とメンテナス性が両立していると思われるReactを採用する。

### Q30: Rust バックエンドとの連携方式
- 既存 `Backend` 構造体を Tauri どのように呼び出すか？
  - 方針: `tauri::State` に共有バックエンドを保持し、コマンドハンドラ経由で同期 API を提供する。リアルタイム更新はバックエンド→フロントエンドにイベント送出（`emit_all`）する案を検討する。TUI 依存の入出力層を分離し、GUI 用の薄いアダプタを作成する必要がある。
  - 回答:上記方針で問題ないです。

### Q31: キー入力とコマンド伝播
- Web フロントエンドで受け取ったキーイベントをどの単位でバックエンドへ渡すか？
  - 未決: フロントエンド側で Emacs 風キーバインドを再実装するか、キーシーケンスをそのままバックエンドへ渡して解決するかを検討中。既存の `KeySequence` 定義を共有できるよう Rust ↔ TypeScript のシリアライズ形式を決める必要がある。
  - 回答: フロントエンド層は依存度を下げ薄くしたい。理由としてはコアアーキテクチャをalisp言語実装とバッファ等のバックエンドシステムに据え置きたいため。また、極力フロントエンド依存を避けたい(TUI/GUI両立のため)。

### Q32: 画面更新モデル
- バックエンドからのテキスト・ミニバッファ更新はポーリングとイベント駆動のどちらで行うか？
  - 方針: 初期実装はリクエスト毎にスナップショットを返す pull 型で実装し、性能要件が出た段階で push 型イベント（差分更新）へ拡張する。差分生成ロジックのコスト見積りが必要。
  - 回答: 性能要件は後回しにしたい。まずは、最低限動作することを目指す。このため、pull型実装で問題ない。

### Q33: ファイルアクセス制御
- Tauri のファイル API をどのように許可し、ホストファイル操作を安全に行うか？
  - 方針: 既存の Rust 側ファイル I/O を継続利用する。Tauri 側では `fs` プラグインの使用を抑え、編集対象ルートのホワイトリストを Rust バックエンドで検証する。ダイアログ利用可否（`tauri-plugin-dialog`）は別途決定。
  - 回答: Tauriではファイル参照しないこと。あくまでファイルやバッファのコントロールはrust側実装に任せ、tauriは最低限のフロントエンド表現と入力受付のみを担うこと。

### Q34: ビルド/テストフロー
- Node.js 依存や `npm install` が必要になるが、オフライン環境でどう運用するか？
  - 未決: `pnpm` ロックファイルをコミットするか、`npm` + vendored `node_modules` を採用するか判断が必要。CI でのキャッシュ戦略、`tauri-cli` の入手方法も合わせて検討する。
  - 回答: 現状の作業環境はオンラインです。ただし作業環境がnixosであるため、通常期待する通りのコマンドが稼働しないことがあるかと思います。nixos環境を前提として作業を行い、それでも、疎通エラーが発生する場合はその都度報告し、エラー内容の詳細を説明してください。

### Q35: デバッグとログ収集
- GUI デバッグログをどの形式で記録し、CLI から参照できるようにするか？
  - 方針: 旧 `DebugLogger` 相当の JSON Lines 出力を Tauri 側から生成し、`debug/tauri-debug.log` などに保存する案を検討する。フロントエンドの console ログは devtools 依存になりやすいため、Rust 側に集中させる。
  - 回答: ~/.altre-log/debug.logディレクトリを作成し、ここにデバッグ用のログを出力させる。動作確認時はここを参照すること。また、コマンドラインオプションにデバッグログが出力できるようにするためのコマンドオプションをつけること。ログ形式やファイルフォーマット、ファイル名などは別途適切なものを検討すること。

## 次のアクション

上記の質問について回答いただいた後、具体的な実装計画を立てて開発を開始したいと思います。
特に優先度が高いのは：
1. プロジェクト構成の決定（ディレクトリ作成）
2. 依存関係の選定（確定）
3. MVP実装順序の確定（機能洗い出し）
4. 初期Rustプロジェクトのセットアップ

です。

回答が完了次第、プロジェクトの初期セットアップから開始します。
